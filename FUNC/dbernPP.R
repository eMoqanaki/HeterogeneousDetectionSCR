## 3. ------ DEFINE CUSTOM DISTRIBUTION FUNCTIONS ------
### 3.1. ==== dbernPP - Bernoulli Point Process ====
## 3.1.1. dbernPP density function ----
#' @title Probability Density of a Bernoulli Point Process 
#' 
#' @description Probability density function for a Bernoulli point process (a binomial point process 
#' with one point only) observed within a set of observation windows.
#' 
#' @param x A vector of coordinates of one point generated from the point process.
#' @param lowerCoords A matrix containing the lower coordinates of the observation windows. 
#' Each row represents an observation window.
#' @param upperCoords A matrix containing the upper coordinates of the observation windows. 
#' Each row represents an observation window.
#' @param intensityWeights A vector of length equal to the number of observation windows.
#' Sets the baseline intensity for each observation window.
#' @param windowSizes A vector of observation window sizes.
#' @param sumIntensity A value calculated by integrating the intensity function over the whole spatial domain. 
#' A discrete summation when the domain is divided into grid cells. This value is obtained by summing up
#' the product of \code{intensityWeights} and \code{windowSizes}; however providing this as an argument 
#' helps to reduce some calculations when the function is used repeatedly in a loop in some cases.
#' @param numPoints The number of points generated by the point process. 
#' If this value is non-zero then one point will be generated. 
#' This is useful for NIMBLE models where \code{dbinomPP} is nested in a loop and 
#' where there may be zero points in some cases.
#' @param numWindows The number of observation windows. If this value is less than zero
#' then the number of windows is taken from \code{dim(lowerCoords)[1]}. The value
#' is then used to truncate \code{lowerCoords} and \code{upperCoords} (so that extra rows
#' beyond \code{numWindows} are ignored). This is useful when using this function in
#' NIMBLE models where \code{dbernPP} is nested in a loop and where may be zero or one
#' observation window in some cases.
#' @param parsCheck If \code{TRUE} then check the validity of the input parameter(s).
#' @param log If \code{TRUE} then return the log density.
#' 
#' @return A scalar containing the (log) probability density.
#' 
#' @author Wei Zhang
#' @export
#' 
dbernPP <- nimbleFunction(
  run = function(
    x                = double(1),
    lowerCoords      = double(2),
    upperCoords      = double(2),
    intensityWeights = double(1),
    sumIntensity     = double(0),
    numPoints        = integer(0),
    habitatGrid      = double(2),
    log              = integer(0, default = 0)
  ){
    ## Likelihood is one if there are zero points
    if(numPoints == 0) {
      if(log){
        return(0.0) 
      } 
      else {
        return(1.0)
      } 
    }
    nrowMax <- dim(habitatGrid)[1]
    ncolMax <- dim(habitatGrid)[2]
    # MAKE SURE THE POINT FALLS WITHIN THE HABITAT 
    if(x[2] < 0 |  x[2] > ncolMax | x[1] < 0 | x[1] > nrowMax){
      if(log) {
        return(-Inf)
      } else {
        return(0.0)
      }
      
    }else{
      ## Find which window the point x falls within
      windowInd <- habitatGrid[trunc(x[2])+1, trunc(x[1])+1]
      pointIntensity <- intensityWeights[windowInd]
    }
    
    ## Log probability density 
    outProb <- log(pointIntensity) - log(sumIntensity)
    if(log == 0) {
      outProb <- exp(outProb)
    }
    return(outProb)
    returnType(double(0))
  }
)

## 3.1.2. dbernPP simulation function ----
#' @title Generate a Sample from a Bernoulli Point Process
#' 
#' @description Function to generate a sample (i.e. one point) from a Bernoulli
#' point process for a series of observation windows.
#' 
#' @param n The number of samples to generate (this should always be set to 1)
#' @param lowerCoords A matrix containing the lower coordinates of the observation
#' windows. Each row represents an observation window.
#' @param upperCoords A matrix containing the upper coordinates of the observation
#' windows. Each row represents an observation window.
#' @param intensityWeights A vector of length equal to the number of observation windows.
#' Sets the baseline intensity for each observation window.
#' @param windowSizes A vector of all the observation window sizes.
#' @param sumIntensity A value calculated by integrating the intensity function over the whole spatial domain. 
#' A discrete summation when the domain is divided into grid cells. This value is obtained by summing up
#' the product of \code{intensityWeights} and \code{windowSizes}; however providing this as an argument 
#' helps to reduce some calculations when the function is used repeatedly in a loop in some cases. 
#' @param numPoints The number of points generated by the point process. 
#' If this value is non-zero then one point will be generated. 
#' This is useful for NIMBLE models where \code{dbinomPP} is nested in a loop and 
#' where there may be zero points in some cases.
#' @param numWindows The number of observation windows. If this value is less than zero
#' then the number of windows is taken from \code{dim(lowerCoords)[1]}. The value
#' is then used to truncate \code{lowerCoords} and \code{upperCoords} (so that extra rows
#' beyond \code{numWindows} are ignored). This is useful when using this function in
#' NIMBLE models where \code{dbernPP} is nested in a loop and where may be zero or one
#' observation window in some cases.
#' @param parsCheck If \code{TRUE} then check the validity of the input parameter(s).
#' 
#' @return A vector of coordinates for a point generated from the Bernoulli point process
#' 
#' @author Wei Zhang
#' @export
#' 
rbernPP <- nimbleFunction(
  run = function(
    n                = integer(0),
    lowerCoords      = double(2),
    upperCoords      = double(2),
    intensityWeights = double(1),
    sumIntensity     = double(0),
    numPoints        = integer(0),
    habitatGrid      = double(2)
    
  ){
    if(n <= 0) {
      stop("the number of requested samples must be above zero")
    } else if(n > 1) {
      print("rbernPP only allows n = 1; using n = 1")
    }  
    ## Ensure that there is at least one window with non-zero size         
    # if(sum(windowSizes) == 0){ 
    #   stop("at least one of the observation windows should have a non-zero size")
    # }
    ## If no points to be generated, return a null vector
    if(numPoints == 0) {
      outCoordinates <- numeric(length = 0)
      return(outCoordinates)
    } 
    ## Intensities of all windows
    areaIntensities <- intensityWeights #* windowSizes
    ## Observation window index
    obsWindowInd <- rcat(1, areaIntensities)
    ## Generate coordinates within the relevant observation window
    targetLowerCoords <- lowerCoords[obsWindowInd,]
    targetUpperCoords <- upperCoords[obsWindowInd,]
    numDims <- dim(lowerCoords)[2]
    outCoordinates <- targetLowerCoords[1:numDims] + runif(numDims, 0.0, 1.0) * (targetUpperCoords[1:numDims] - targetLowerCoords[1:numDims])
    
    return(outCoordinates)
    returnType(double(1)) 
  }
)


registerDistributions( list(
  ## 1.1.1. Define the dbernPP distribution ----
  dbernPP = list(
    # Define the BUGS code to call the distribution
    BUGSdist = "dbernPP(lowerCoords, upperCoords, intensityWeights, sumIntensity, numPoints, habitatGrid)",
    # Set the input and output types and dimension structure
    types = c("value = double(1)", "lowerCoords = double(2)", "upperCoords = double(2)", "intensityWeights = double(1)", 
              "sumIntensity = double(0)", "numPoints = double(0)","habitatGrid = double(2)"),
    # Define the cumulative probability and quantile function availability
    pqAvail = FALSE,
    mixedSizes = TRUE   # Turn off warnings about possible dimension mismatch
  )
)
)